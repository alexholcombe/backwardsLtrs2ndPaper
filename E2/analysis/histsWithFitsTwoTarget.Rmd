---
title: "inspect histograms"
author: "Alex Holcombe"
date: "2/26/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)

```

Load data and estimates

```{r load data, echo=FALSE, message=FALSE}

#Import raw data
dataPath<- file.path("../Data/")
#Experiment was administered by MATLAB
#.mat file been preprocessed into melted long dataframe by importE1data.Rmd
data<- readRDS( file.path(dataPath, "backwards2E2_rawDataFromMAT.rda") ) 

resultsPath<- file.path("Results")
estimates<- read.csv(file = file.path(resultsPath,"/backwards2E2_paramEstimates.csv"))

```

Fix the variable names if not done

```{r, echo=FALSE, message=FALSE}
#Below should now be done by import
if ('target' %in% names(data)) {
  names(data)[names(data) == 'target'] <-'stream'
  names(data)[names(data) == 'condition'] <-'orientation'
  data$stream[ data$stream==1 ] <- "Left"
  data$stream[ data$stream==2 ] <- "Right"
}
if (is.numeric(data$targetSide)) {
  data$targetSide[ data$targetSide==0 ] <- "Both"
  data$targetSide[ data$targetSide==1 ] <- "Left"
  data$targetSide[ data$targetSide==2 ] <- "Right"
}
if (is.numeric(data$orientation)) {
  #mutate condition to Orientation
  data$orientation[ data$orientation==1 ] <- "Canonical"
  data$orientation[ data$orientation==2 ] <- "Inverted"
}
```

Add the parameter estimates to the tibble

```{r, echo=FALSE, message=FALSE, fig.height=360, fig.width=10}
#want fig.height of 10 per subject

condtnVariableNames <- c("subject","stream", "orientation","targetSide")  

#Add R parameter estimates to data tibble
#To merge them, unfortunately have to convert to dataframe first because dplyr has no binding of tibbles.
# https://stackoverflow.com/questions/45643886/how-to-combine-tibbles-with-common-but-non-identical-columns#45644319
#Not sure what is lost as a result.
dd<- as_data_frame(data)
es<- as_data_frame(estimates)
#Looks like each subject has only 8 efficacy values somehow, it's because there was an extra
#variable, X
es$X <- NULL
dat<- merge(dd,es)
dg<-dat %>% filter( !is.na(targetSP) ) #excluding 1-target trials rows reporting stream on opposite side. Eventually, use those to evaluate swaps.
```

Set up the experiment-specific parameters 

```{r detailsNeeded}

numItemsInStream<- length( dg$letterSeq[[1]] )  
minSPE<- -17; maxSPE<- 17
annotateIt<-TRUE

numSs<-length(unique(dg$subject))
cat( paste0('Total num Ss=',numSs) )
```

Calc numObservations for each condition
```{r }
#Calc numObservations for each condition. This is needed  for scaling the fine-grained Gaussian
#gaussianScaledforData needs to know.
if (!("nPerCond" %in% colnames(dg))) {
  dfGroups<-  dg  %>%  filter( !is.na(targetSP) ) %>% group_by_at(.vars = condtnVariableNames) %>% summarise(nPerCond = n())
  #add nPerCond back to parameter estimates
  estimates<- merge(estimates,dfGroups)
}
```



Calculate curves for parameters, to plot on histograms.
```{r, echo=TRUE, message=FALSE, fig.height=360, fig.width=10}
#devtools::install_github('alexholcombe/mixRSVP',build_vignettes=TRUE)
library(mixRSVP)

curves<- dg %>% #filter(subject >= "AA" ) %>%
  group_by_at(.vars = condtnVariableNames) %>% 
  do(calc_curves_dataframe(.,minSPE,maxSPE,numItemsInStream))
#fails with on-missing arguments to min; returning Inf no non-missing arguments to max; returning -Inf 
#Error in createGuessingDistribution(minSPE, maxSPE, df$targetSP, numItemsInStream) :  minSPE must be less than or equal to maxSPE

#DEBUG
# dd<- dg %>% filter(subject=="AA", stream=="Left",targetSide=="Both",orientation=="Canonical")
# 
# createGuessingDistribution(minSPE,maxSPE,dd$targetSP,numItemsInStream)
# targetSP<- dd$targetSP
# maxTargetSP <- max(targetSP)
# minSPEthisData<- 1 - max(targetSP)
# maxSPEthisData<- numItemsInStream - min(targetSP)
# if (maxSPEthisData > maxSPE) stop("maxSPE must be at least",maxSPEthisData,"based on the values you passed me")
# if (minSPEthisData < minSPE) stop("minSPE must be no greater than",minSPEthisData,"based on the values you passed me")
# calc_curves_dataframe(dd,minSPE,maxSPE,numItemsInStream)


```


```{r }
# #Calc numObservations to each condition. This is needed only for scaling the fine-grained Gaussian
# #Calc the number of observations for each condition, because gaussianScaledforData needs to know.
# dfGroups<- dg %>% group_by_at(.vars = condtnVariableNames) %>% summarise(nPerCond = n())
# #add nPerCond back to parameter estimates
# estimates<- merge(estimates,dfGroups)

grain<-.05
gaussFine<- estimates %>% group_by_at(.vars = condtnVariableNames) %>% do(
  gaussian_scaled_from_df(.,minSPE,maxSPE,grain) )
```


Plot sample histograms, make sure plotting working.

```{r singleHistPlot}
library(ggplot2)

dAC<- dplyr::filter(dg,subject=="AC")  
plotContinuousGaussian<- TRUE 
annotateIt<-TRUE
g<- plot_hist_with_fit(dAC,minSPE,maxSPE,d915$targetSP,numItemsInStream,
                        plotContinuousGaussian,annotateIt, FALSE)
g <- g + geom_vline(xintercept = 0)
g + annotate("text", x = 12, y = 25, label = "AC")
```

Show single plot with curves using scalable method to facet_grid
```{r singleHistPlotScalable, echo=FALSE}

dAC<- dplyr::filter(dg,subject=="AC")  
bothSides<- dAC %>% filter(targetSide=="Both")
bothSidesCurves <- curves %>% filter(subject=="AC") %>% filter(targetSide=="Both")

g=ggplot(bothSides, aes(x=SPE)) + 
        facet_grid(orientation~stream) #,  scales="free_y")
g<-g+geom_histogram(binwidth=1,color="grey90") + xlim(minSPE,maxSPE)
g<-g+ geom_text(x=12, y= 33, aes(label = subject)) #inset subject name/number. Unfortunately it overwrites itself a million times
g<-g +theme_apa() #+theme(panel.grid.minor=element_blank(),panel.grid.major=element_blank())# hide all gridlines.
g<-g +xlim(minSPE,maxSPE)
sz=.3
#show(g)
g<-g+ geom_point(data=bothSidesCurves,aes(x=x,y=combinedFitFreq),color="chartreuse3",size=sz)

#g<-g+ geom_line(data=curves,aes(x=x,y=guessingFreq),color="yellow",size=sz)
#Discretized Gaussian
#g<-g+ geom_line(data=curves,aes(x=x,y=gaussianFreq),color="lightblue",size=sz)

#mixSig - whether mixture model statistically significantly better than guessing
bothSidesCurves <- dplyr::mutate(bothSidesCurves, mixSig = ifelse(pLRtest <= .05, TRUE, FALSE)) #annotate_fit uses this to color the p-value
g<- annotate_fit(g,bothSidesCurves) #assumes curvesDf includes efficacy,latency,precision
#Somehow the which mixSig (TRUE or FALSE) is red and which green is flipped relative to plot_hist_with_fit even though
#identical commands are used. I haven't been able to work out why.
#g<- g + scale_color_manual(values=c("red","forestgreen")) #already done in annotate_fit
show(g)
```

Make sure can plot without plot_hist_with_fit

Plot all Ss
```{r, fig.height=200, fig.width=10}

bothSides<- dg %>% filter(targetSide=="Both")
bothSidesCurves <- curves %>% filter(targetSide=="Both")

g=ggplot(bothSides, aes(x=SPE)) + 
        facet_grid(subject+orientation~stream) #,  scales="free_y")
g<-g+geom_histogram(binwidth=1,color="grey90") + xlim(minSPE,maxSPE)
g<-g+ geom_text(x=12, y= 33, aes(label = subject)) #inset subject name/number. Unfortunately it overwrites itself a million times
g<-g +theme_apa() #+theme(panel.grid.minor=element_blank(),panel.grid.major=element_blank())# hide all gridlines.
g<-g +xlim(minSPE,maxSPE)
sz=.3
#show(g)
g<-g+ geom_point(data=bothSidesCurves,aes(x=x,y=combinedFitFreq),color="chartreuse3",size=sz)
#g<-g+ geom_line(data=curves,aes(x=x,y=guessingFreq),color="yellow",size=sz)
#Discretized Gaussian
#g<-g+ geom_line(data=curves,aes(x=x,y=gaussianFreq),color="lightblue",size=sz)

#mixSig - whether mixture model statistically significantly better than guessing
bothSidesCurves <- dplyr::mutate(bothSidesCurves, mixSig = ifelse(pLRtest <= .05, TRUE, FALSE)) #annotate_fit uses this to color the p-value
g<- annotate_fit(g,bothSidesCurves) #assumes curvesDf includes efficacy,latency,precision
#Somehow the which mixSig (TRUE or FALSE) is red and which green is flipped relative to plot_hist_with_fit even though
#identical commands are used. I haven't been able to work out why.
#g<- g + scale_color_manual(values=c("red","forestgreen")) #already done in annotate_fit
show(g)

```

CY is bimodal but not outrageously so.

Subject AP looks to both have close to zero efficacy in some conditions and disregards instructions, reporting mostly after the cue.

BJ has essentially zero efficacy and may have tended to report letters from beginning of stream in one condition.
```{r }
SsWhoLookWeird<-c("CY","AP","BJ")
```
We'll see whether the statistical comparison of mixture modeling to guessing distribution flags these as not being fit significantly better by mixture model. 

AP, BJ does flunk likelihood test! CY passes but data not horrifyingly bad.
Exclude by likelihood ratio test

Participant AI, BB suspicion of  attending to one side, let's see which people fail single-target test.

```{r singleTarget}
oneSide<- dg %>% filter(targetSide!="Both")
oneSideCurves <- curves %>% filter(targetSide!="Both")

g=ggplot(oneSide %>% filter(subject=="AA"), aes(x=SPE)) + 
        facet_grid(subject+orientation~stream) #,  scales="free_y")
g<-g+geom_histogram(binwidth=1,color="grey90") + xlim(minSPE,maxSPE)
show(g)
g<-g+ geom_text(x=12, y= 33, aes(label = subject)) #inset subject name/number. Unfortunately it overwrites itself a million times
g<-g +theme_apa() #+theme(panel.grid.minor=element_blank(),panel.grid.major=element_blank())# hide all gridlines.
g<-g +xlim(minSPE,maxSPE)
sz=.3
show(g)
g<-g+ geom_point(data=oneSideCurves,aes(x=x,y=combinedFitFreq),color="chartreuse3",size=sz)
#g<-g+ geom_line(data=curves,aes(x=x,y=guessingFreq),color="yellow",size=sz)
#Discretized Gaussian
#g<-g+ geom_line(data=curves,aes(x=x,y=gaussianFreq),color="lightblue",size=sz)

#mixSig - whether mixture model statistically significantly better than guessing
bothSidesCurves <- dplyr::mutate(oneSideCurves, mixSig = ifelse(pLRtest <= .05, TRUE, FALSE)) #annotate_fit uses this to color the p-value
g<- annotate_fit(g,oneSideCurves) #assumes curvesDf includes efficacy,latency,precision
#Somehow the which mixSig (TRUE or FALSE) is red and which green is flipped relative to plot_hist_with_fit even though
#identical commands are used. I haven't been able to work out why.
#g<- g + scale_color_manual(values=c("red","forestgreen")) #already done in annotate_fit
show(g)
```
